use crate::Params;

pub struct Stability {
    c_bar: f64,
    // wing
    c_law: f64, // lift curve slope at mach cruise
    x_acw: f64,
    s_w: f64,
    // tail
    c_lah: f64,
    x_ach: f64,
    s_h: f64,
    eta_h: f64, // tail efficiency factor
    // fuselage pitching moment
    k_f: f64,
    l_f: f64,
    w_f: f64,
    // compute downwash
    ar: f64,
    lambda: f64,
    h_h: f64,
    l_h: f64,
    b: f64,
    sweep: f64, // quarter chord sweep
    c_law0: f64, // lift curve slope at mach 0
}

impl Stability {
    pub fn new(params: &Params) -> Self {
        Self {
            c_bar: params.get("c_bar").expect("missing c_bar").clone(),
            // wing
            c_law: params.get("c_law").expect("missing c_law").clone(), // lift curve slope at mach cruise
            x_acw: params.get("x_acw").expect("missing x_acw").clone(),
            s_w: params.get("s_w").expect("missing s_w").clone(),
            // tail
            c_lah: params.get("c_lah").expect("c_lah").clone(),
            x_ach: params.get("x_ach").expect("missing x_ach").clone(),
            s_h: params.get("s_h").expect("missing s_h").clone(),
            eta_h: params.get("eta_h").expect("missing eta_h").clone(), // tail efficiency factor
            // fuselage pitching moment
            k_f: params.get("k_f").expect("missing k_f").clone(),
            l_f: params.get("l_f").expect("missing l_f").clone(),
            w_f: params.get("w_f").expect("missing w_f").clone(),
            // compute downwash
            ar: params.get("ar").expect("missing ar").clone(),
            lambda: params.get("lambda").expect("missing lambda").clone(),
            h_h: params.get("h_h").expect("missing h_h").clone(),
            l_h: params.get("l_h").expect("missing l_h").clone(),
            b: params.get("b").expect("missing b").clone(),
            sweep: params.get("sweep").expect("missing sweep").clone(), // quarter chord sweep
            c_law0: params.get("c_law0").expect("missing c_law0").clone(), // lift curve slope at mach 0
        }
    }

    /// not power effect
    pub fn dcmcg_da(&self, x_cg: f64) -> f64 {
        - self.c_law * (self.x_acw - x_cg) / self.c_bar +
        self.c_maf() -
        self.eta_h * self.c_lah * (1. - self.depsi_da()) * self.s_h / self.s_w * (self.x_ach - x_cg) / self.c_bar
    }

    pub fn x_np(&self) -> f64 {
        let depsi_da = self.depsi_da();
        self.c_bar * (
            self.c_law * self.x_acw / self.c_bar -
            self.c_maf() +
            self.eta_h * self.c_lah * (1. - depsi_da) * self.s_h / self.s_w * self.x_ach / self.c_bar
        ) / (
            self.c_law + self.eta_h * self.c_lah * (1. - depsi_da) * self.s_h / self.s_w
        )
    }

    /*
    pub fn neutral_point(&self) -> f64 {
        let c_maf = self.c_maf();
        let depsi_da = self.depsi_da();
        (
            self.c_law * self.x_acw / self.c_bar - c_maf +
            self.eta_h * self.c_lah * (1. * depsi_da) * self.s_h / self.s_w * self.x_ach / self.c_bar
        ) / (self.c_law + self.eta_h * self.c_lah * (1. + depsi_da) * self.s_h / self.s_w)
    }        
    */

    /// Returns the pitching moment generated by the fuselage about the CG.
    /// k_f: empirical factor obtained from graph
    /// l_f: fuselage length
    /// w_f: fuselage max width
    /// c_bar: mean aerodynamic chord
    /// s_w: wing reference area
    fn c_maf(&self) -> f64 {
        self.k_f * self.l_f * self.w_f * self.w_f * self.c_bar * self.s_w
    }

    /// Variation of downwash angle with wing angle of attack (empirical).
    /// ar: wing aspect ratio
    /// lambda: wing taper ratio
    /// h_h: wing chord to horizontal tail chord vertical distance
    /// l_h: wing quarter chord position to horizontal tail quarter chord position horizontal distance
    /// b: wing span
    /// sweep: wing quarter chord sweep (radians)
    /// c_law:
    /// c_law0:
    fn depsi_da(&self) -> f64 {
        let k_a = 1. / self.ar - 1. / (1. + self.ar.powf(1.7));
        let k_lambda = (10. - 3.*self.lambda) / 7.;
        let k_h = (1. - f64::abs(self.h_h/self.b)) / f64::powf(2. * self.l_h / self.b, 1./3.);
        4.44 * f64::powf(k_a * k_lambda * k_h * self.sweep.cos().sqrt(), 1.19) * self.c_law / self.c_law0
    }
}

