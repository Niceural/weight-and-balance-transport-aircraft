use crate::Params;

#[derive(Copy, Clone)]
pub struct Stability {
    c_bar: Option<f64>,
    // wing
    c_law: Option<f64>, // lift curve slope at mach cruise
    x_acw: Option<f64>,
    s_w: Option<f64>,
    // tail
    c_lah: Option<f64>,
    x_ach: Option<f64>,
    s_h: Option<f64>,
    eta_h: Option<f64>, // tail efficiency factor
    // fuselage pitching moment
    k_f: Option<f64>,
    l_f: Option<f64>,
    w_f: Option<f64>,
    // compute downwash
    ar: Option<f64>,
    lambda: Option<f64>,
    h_h: Option<f64>,
    l_h: Option<f64>,
    b: Option<f64>,
    sweep: Option<f64>, // quarter chord sweep
    c_law0: Option<f64>, // lift curve slope at mach 0
}

impl Stability {
    /// not power effect
    pub fn dcmcg_da(self) -> Option<f64> {
        Some(
            - self.c_law? * (self.x_acw? - self.x_cg?) / self.c_bar? +
            self.c_maf()? -
            self.eta_h? * self.c_lah? * self.depsi_da()? * self.s_h? / self.s_w? * (self.x_ach? - self.x_cg?) / self.c_bar?
        )
    }

    pub fn neutral_point(self) -> Option<f64> {
        let c_maf = self.c_maf()?;
        let depsi_da = self.depsi_da()?;
        Some(
            (
                self.c_law? * self.x_acw? / self.c_bar? - c_maf +
                self.eta_h? * self.c_lah? * (1. * depsi_da) * self.s_h? / self.s_w? * self.x_ach? / self.c_bar?
            ) / (self.c_law? + self.eta_h? * self.c_lah? * (1. + depsi_da) * self.s_h? / self.s_w?)
        )
    }        

    /// Returns the pitching moment generated by the fuselage about the CG.
    /// k_f: empirical factor obtained from graph
    /// l_f: fuselage length
    /// w_f: fuselage max width
    /// c_bar: mean aerodynamic chord
    /// s_w: wing reference area
    fn c_maf(self) -> Option<f64> {
        Some(self.k_f? * self.l_f? * self.w_f? * self.w_f? * self.c_bar? * self.s_w?)
    }

    /// Variation of downwash angle with wing angle of attack (empirical).
    /// ar: wing aspect ratio
    /// lambda: wing taper ratio
    /// h_h: wing chord to horizontal tail chord vertical distance
    /// l_h: wing quarter chord position to horizontal tail quarter chord position horizontal distance
    /// b: wing span
    /// sweep: wing quarter chord sweep (radians)
    /// c_law:
    /// c_law0:
    fn depsi_da(self) -> Option<f64> {
        let k_a = 1. / self.ar? - 1. / (1. + self.ar?.powf(1.7));
        let k_lambda = (10. - 3.*self.lambda?) / 7.;
        let k_h = (1. - f64::abs(self.h_h?/self.b?)) / f64::powf(2. * self.l_h? / self.b?, 1./3.);
        Some(4.44 * f64::powf(k_a * k_lambda * k_h * self.sweep?.cos().sqrt(), 1.19) * self.c_law? / self.c_law0?)
    }
}

